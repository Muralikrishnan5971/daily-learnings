

Git you have three levels of settings files, 
in repository, global for your user and global for the whole computer with all its users. 
git config --list will list all of them that are in effect in the place where you are.

.gitconfig is one of four configuration files that git config --list will search for configuration options. 
.gitconfig contains only the user-specific configurations (also called global configuration), but you can also have system-specific and repository-specific configurations. To get a full view of the configuration in your current directory, you should use git config --list.

git config user.name                                   --> reads user.name from the git config file
git config --global user.name "muralikrishnan"         --> sets the username

git config user.eamil                                  --> reads user.eamil from the git config file
git config --global user.email "muralikrishnan"        --> sets the email

To configure the initial branch name to use in all of your new repositories, which will suppress this warning, call:

git config --global init.defaultBranch <name>          --> like main, master, trunk, develoment

we can also rename the just-created branch with the below command

git branch -m <name>                                    --> git branch -m main or git branch -m master

git init   --> initializes a repo
creates a hidden .git folder

.git folder consisits of below files and directories

files,

HEAD
config
description

directories,
hooks
info
objects
refs

There can be other files and directories as well inside it as we start configuring and using.

git add filename1 filename2
git add .

git status -u                     --> shows untracked files and directories

The working tree, or working directory, consists of files that you are currently working on. You can think of a working tree as a file system where you can view and modify files. The index, or staging area, is where commits are prepared. The index compares the files in the working tree to the files in the repo.

git rm --cached <file>            --> to unstage

git config --global core.editor "code --wait"       --> to set vs code as text editor for typing commit messages

--global flag means it applies to all the repos  

git log --pretty        --> pretty prints the commit messages
git log --oneline       --> prints only one line from the commit message

git commit --ammend     ---> The git commit --amend command is a convenient way to modify the most recent commit. It lets you combine staged changes with the previous commit instead of creating an entirely new commit.

example:

git commit -m "new changes added"
opps some changes missed and now added
git add .
git commit --amend    ---> this opens up the previous commit message which can be updated.

in case we need only to edit the latest commit message, git commit --amend will open up commit message editor.

.gitignore file   created at the root of a repository

filename.txt   --> ignores the file filename.txt
foldername/    --> ignores the contents of the folder foldername
*.log          --> ignores all the files with .log extension

*******   gitignore.io   --> check this out

When we make a commit, each commit get this wierd looking hash (hash code)
algorithm used by hashing function in git is sha1

Every commit has a unique identifier, ie., unique hash
And each commit references atleast one parent commit that came before it 

master or main branch is just like any other branch

comit 2f24r34tr35tr3445253454354fdwfwefw (HEAD -> master)

HEAD is a pointer that refers to current location in our repository,
It points to a particular branch reference.

git branch     --> lists all our branches

git branch <branchname>    --> creates a new branch given name, but does not switch to it. 
i.e., iam still on the master branch

once new branch is created, the HEAD will be pointing to both the branch, like the below example

commit 482398c2e0a00ca1f3e0c5ede509a2eeb76d2f4b (HEAD -> songs, tamilsongs)

git switch <branchname> switches to the specified branch  --> it is a new command, the same was done earlier using git checkout

after commiting some changes, doing git log, we can see the HEAD pointing to the latest active branch

commit aabba92ff3b36c51e4ebfcc92686415f4445efdd (HEAD -> tamilsongs)

git commit -a -m "commit message"  --> to directly stage all changes and commit

it does matter where we branch from.

***  git checkout branchname    --> switches to the branch specified
***  but git checkout does a lot more

git switch -c branchname    ---> creates a new branch and switches to it.

-c stands for create

git checkout -b branchname  ---> creates a new branch and switches to it.

Now we have done some changes in the existing files, now try to switch to another branch, it will not switch and throw the below error.

error: Your local changes to the following files would be overwritten by checkout:
	playlist.txt
Please commit your changes or stash them before you switch branches.
Aborting

The same thing does not apply when we create a new file, work on it and then try to switch from there, we can switch.
since the new file is yet to be commited.


good practice is to always add and commit changes or stash before switching

git switch -d branchname  --> deletes only when all changes are merged
git switch -D branchname  --> force deletes irrespective of the merge status


when we try to delete current branch from the active branch, we cannot do that and get below error msg:
error: Cannot delete branch 'deletemebranch' checked out at '/Users/muralikrishnan/Desktop/murali/dummy_git/roadtrip'

to delete irrespective of its merge status use -D option, git branch -D branchname

To rename a branch
first change to the branch we want to rename, then use the below command

git branch -m newname       ---> -m option stands for move/rename 

Each HEAD references the branch and
Each branch reeferences to a commit


In the .git folder HEAD file will store always, where the head is present in the below format
ref: refs/heads/harrissongs

in .git/ref/head   --> this folder contains all the branches as files, where it stores the latest commits hash value

git Merging

*** we merge branches not specific commits
*** we always merge to current HEAD branch

Steps to merge

1. checkout to the branch we want to merge the changes into (receiving branch) --> git checkout master
2. use the git merge command to merge a specific change to the current branch  --> git merge bugfix

remember the branches are just defined by a branch pointer
master and bugfix now point to the same commit, until they diverge again  --> in our example
This is called a Fast Forward.

*****************************************
Setting up a global .gitignore file.

You can create a global gitignore
create a ~/.gitignore in your user directory, then

git config --global core.excludesfile ~/.gitignore

git log --graph
git log --graph --all
git log --graph --decorate --oneline

https://stackoverflow.com/questions/1838873/visualizing-branch-topology-in-git

git remote add origin remote-repo-url

git branch -m main

git push -u origin main

To merge branches, switch to the branch we want changes to be merged

git switch master

Then git merge feature-branch-name

git automatically merge commits the feature-branch changes to the master and prompts us for a commit msg.

When we try to merge branches, where there is no chance of conflicts, git commits the changes to the recipient branch and promtps us for an commit message. So this merge commit will have two parent commits. One from the recipient branch, other from the giving branch.


https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/addressing-merge-conflicts/resolving-a-merge-conflict-using-the-command-line

Resolving merge conflicts

when two people try to merge different changes to same line and file, we get merge conflicts. No git does'nt know how to merge these conflicts automatically, so we need to fix it.

git throws the following error:
Auto-merging playlist.txt
CONFLICT (content): Merge conflict in playlist.txt
Automatic merge failed; fix conflicts and then commit the result.

Also, the files where there are conflicts are decorated. They have new content to indicate where there are conflicts.

If you have questions, please
<<<<<<< HEAD                         --> content in the branch we are trying to merge into
open an issue
=======
ask your question in IRC.
>>>>>>> branch-a                     --> content from the branch we are trying to merge from

To see the beginning of the merge conflict in your file, search the file for the conflict marker <<<<<<<. When you open the file in your text editor, you'll see the changes from the HEAD or base branch after the line <<<<<<< HEAD. Next, you'll see =======, which divides your changes from the changes in the other branch, followed by >>>>>>> BRANCH-NAME. In this example, one person wrote "open an issue" in the base or HEAD branch and another person wrote "ask your question in IRC" in the compare branch or branch-a.

we go through the changes, decide what we want and dont. Remove all the markers


git log --graph --decorate --oneline --all

There are 3 types of merge: the fast-forward merge, three-way merge, and rebasing which I briefly mentioned above

--> Fast-forward merge, as the name implies, is a quick and easy way to merge your branches and continue working on your project. It doesn't require any extra work and you'll rarely run into a merge conflict with it.

This is because all it does is move its HEAD from the current commit of the main branch onto the latest commit of the branch being merged. It's like moving your project forward in time.

--> A three-way merge occurs when the branch you're trying to merge to is ahead of the branch you're trying to merge. For example you create a branch to fix a bug and at the same time, a colleague is working on the main branch. And before you can finish squashing the bug, a new commit has been added to the main branch.

Git won't be able to smoothly integrate your branch into the main branch because the main branch is now ahead of the commit your branch was pointing to.

So it has to create a separate commit for it and combine your commit, the new commit on the main branch, and the commit they're both pointing to (since they both have the same ancestor commit) into one commit in order to merge them as a new commit.

--> The last method, which is rebasing, transfers the whole feature branch onto the main branch.

A downside to rebasing which merge doesn't have is loss of project history. When you merge a branch to another branch, you still have access to that branch until you delete it. But when you rebase a branch you lose access to all of that branch's history. This can be good or bad depending on you, (your team), and your project.


**************************************
Git under the hood

So you could say Git is a database of references to your project. That database is built using three types of objects:

the commits which contain the metadata of every commit such as the message and author,
the tree of changes which contain references to filenames, file contents, and sometimes other trees,
and the blob which represents the actual data held within the files.

**************************************

git diff --> compares Staging area and Working directory

**************************************

git stash will take all uncommited changes, both staged and unstaged

list all changes in the working directory that are not staged for the next commit

git stash save or git stash  --> stashes the uncommited changes

git stash list --> lists all saved stashes

index is what git calls the staging area

git stash pop  --> will remove the most recently stashed changes form the stash and re apply them to your workign directory

good practice, have one stash - git stash, and then reapply it by git stash pop.

git stash apply --> will apply all out changes, but keeps them in our stash

Applying specific stashes
stash@{0}: WIP on master: 9e245f5 add one murugan song
stash@{1}: WIP on master: 9e245f5 add one murugan song
stash@{2}: WIP on master: 9e245f5 add one murugan song
stash@{3}: WIP on master: 9e245f5 add one murugan song
stash@{4}: WIP on master: 9e245f5 add one murugan song

here stash@{0} is the stash id, using which we can apply a particular stash

similarly to delete a stash

git stash drop stash{0}

To clear out all stashes, git stash clear


Detached HEAD

when we checkout to a particular commit, instead of a branch, then it is a Detached head

/** Discarding changes in git **/

Suppose we made some changes, to a file but don't want to keep them. To revert the file back to whatever it looked like when you last commited.

**
git checkout HEAD <filename>   similar to git checkout .
git checkout -- <filename>	

git restore .
git restore <filename>
git restore --staged <filename>
git restore --staged .  --> unstage all files

git checkout is like a swiss knife in the sense that it can do a million things. So new commands were written
git switch --> switch to
git restore --> undo changes


To remove staged file
git restore --staged <filename>

Undoing commits with git reset

git reset <commit hash>  -- commit hash --> first seven letters of the actual commit hash

this removes the commit from the repo, but we can still see those changes in the working directory. 
To remove those we need a hard reset.

git reset --hard <commit hash>   --> git undoes the commits up to the mentioned commit hash and removes those changes in the working directory.
This is on a per baranch basis

git revert does the same as the git reset, but does it as a brand new commit, which then will be prompted for a commit message.

git reset moves the branch pointer backwards as it eliminates commits.

So when to use git revert ??
If you want to reverse some commits that other people have on their machines, then we need to use git revert.
because using git reset will become fatal.


git restore
git reset
git revert

GIT REMOTE
Before pushing anything to github, we need to tell git about our remote repository on github.
We need to set up a 'destination' before pushing

In git, we refer to these 'destinations' as remotes.
Each remote is a url where a hosted repository lives.

The term origin is just a conventional git remote name, but it is not at all special.
When we clone a repo, the default remote name is set up as origin. we can change it, most people leave it.

git push <remote> <local branchname we want to push up to remote>

always change master branch to main by --> git branch -m main

since 2020, github has changed its default banch name to main instead of master

/** if we create a new local branch called feature-branch, do some changes and try to push it to our remote origin, then,
the changes get pushed, but to a new remote branch feature-branch. **/


While often we push a local branch up to a remote branch of the same name --> git push origin main,
we can also push from a local branch to different remote branch --> git push <remote> <local-branch>:<remote-branch>

example: git push origin bug-fix:develop

The above method is totally NOT common,

git push -u origin main  -->  here -u is the option

The -u option allows you to set the upstream of the branch we are pushing. 
we can think of this as a link connecting our local branch to a branch on github

Running git push -u origin main sets the upstream of the local branch, so that it tracks the same branch (main) on the repo.

The main advantage of setting this -u option is that, once it is set git push -u origin main
then we can use the shorthand git push which will push our current branches changes to the upstream

git push -u orgin main is same as git push --set-upstream origin main 


git commmand to untrack file

git rm --cached <filename>

************************************************************************

When we clone a repo (let's say it has one branch named master) to our local, In the local repo, we'll be having two branch references.

1. The regular old master branch (Or whatever the default branch is, when we clone the repo) - > regular branch reference
2. Then there is the Remote Tracking branch reference called origin/master

git branch -r --> to view all remote branches

By default our main branch is already tracking origin/main


we can switch to remote branches by git checkout origin/remote-branch-name   also

we can do git switch <remote-branch-name>  to create a local branch from the remote branch of the same name.
And it sets up to track the remote branch origin/<remote-branch-name>


			    workspace ---- staging(index) ---- local repo ---- remote repo
git add 		workspace -->> staging(index)
git commits					   staging(index) -->> local repo
git push 										   local repo -->> remote repo
git fetch           							   local repo <<-- remote repo
git pull 	    workspace <<-------------------------------------- remote repo


Fetching allows us the download changes from our remote repo, but those changes will not be automatically integrated into our working files.

git fetch <remote>    which is ussually origin. Therefore git fetch origin will do the job.

git fetch    --> if remote is not specified, it defaults to origin.

git pull is another commmand that we use to retreive changes from remote repo. Unlike git fetch, pull actually updates our HEAD branch with 
whatever changes are retreived from the remote. So in a way we can say, git pull = git fetch + git merge.

To pull we need to specify the particular remote and branch we want to pull using git pull <remote> <branch>
Just like with git merge, it matters WHERE we run our git pull command from. Whatever branch we run it from is where the changes will be run into.

git pull origin main ---> would fetch the latest information from the origin's master branch and merge those changes into our current branch.


*************************** /// GIT CLONE /// **************************

https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/

What if there was a better way? Could you get started working in the repository without downloading every version of every file in the entire Git history? Git’s partial clone and shallow clone features are options that can help here, but they come with their own tradeoffs. Each option breaks at least one expectation from the normal distributed nature of Git, and you might not be willing to make those tradeoffs.

If you are working with an extremely large monorepo, then these tradeoffs are more likely to be worthwhile or even necessary to interact with Git at that scale!

There are three ways to reduce clone sizes for repositories hosted by GitHub.

git clone --filter=blob:none <url> creates a blobless clone.
These clones download all reachable commits and trees while fetching blobs on-demand. 
These clones are best for developers and build environments that span multiple builds.

git clone --filter=tree:0 <url> creates a treeless clone. 
These clones download all reachable commits while fetching trees and blobs on-demand. 
These clones are best for build environments where the repository will be deleted after a single build, but you still need access to commit history.

git clone --depth=1 <url> creates a shallow clone. 
These clones truncate the commit history to reduce the clone size. 
This creates some unexpected behavior issues, limiting which Git commands are possible. 
These clones also put undue stress on later fetches, so they are strongly discouraged for developer use. 
They are helpful for some build environments where the repository will be deleted after a single build.

Before digging in on this topic, be sure you are familiar with how Git stores your data, including COMMITS, TREES, and BLOB objects.

Git has a reputation for being confusing. Users stumble over terminology and phrasing that misguides their expectations. 
This is most apparent in commands that “rewrite history” such as git cherry-pick or git rebase. 
In my experience, the root cause of this confusion is an interpretation of commits as diffs that can be shuffled around. 
However, commits are snapshots, not diffs!

Object IDs are hashes
The most important part to know about Git objects is that Git references each by its object ID (OID for short), providing a unique name for the object. 
We will use the git rev-parse <ref> command to discover these OIDs. 
Each object is essentially a plain-text file and we can examine its contents using the git cat-file -p <oid> command.

git-cat-file - Provide content or type and size information for repository objects

git cat-file -p fb4ca6ed2c90698f84393f482a1224313f8339ba

Blobs are file contents
Blob
A blob is short for a Binary Large OBject.
At the bottom of the object model, blobs contain file contents. 
To discover the OID for a file at your current revision, run git rev-parse HEAD:<path>. 
Then, use git cat-file -p <oid> to find its contents.

If I edit the README.md file on my disk, then git status notices that the file has a recent modified time and hashes the contents. 
If the contents don’t match the current OID at HEAD:README.md, then git status reports the file as “modified on disk.
” In this way, we can see if the file contents in the current working directory match the expected contents at HEAD.

$ git rev-parse HEAD:README.md
eb8115e6b04814f0c37146bbe3dbc35f3e8992e0

$ git cat-file -p eb8115e6b04814f0c37146bbe3dbc35f3e8992e0 | head -n 8

Trees are directory listings
Note that blobs contain file contents, but not the file names! The names come from Git’s representation of directories: trees. 
A tree is an ordered list of path entries, paired with object types, file modes, and the OID for the object at that path. 
Subdirectories are also represented as trees, so trees can point to other trees!

$ git rev-parse HEAD^{tree}
75130889f941eceb57c6ceb95c6f28dfc83b609c

$ git cat-file -p 75130889f941eceb57c6ceb95c6f28dfc83b609c  | head -n 15

Trees provide names for each sub-item. Trees also include information such as Unix file permissions, object type (blob or tree), and OIDs for each entry. 
We cut the output to the top 15 entries, but we can use grep to discover that this tree has a README.md entry that points to our earlier blob OID.


Commits are snapshots
A commit is a snapshot in time. Each commit contains a pointer to its root tree, representing the state of the working directory at that time. The commit has a list of parent commits corresponding to the previous snapshots. A commit with no parents is a root commit and a commit with multiple parents is a merge commit. Commits also contain metadata describing the snapshot such as author and committer (including name, email address, and date) and a commit message. The commit message is an opportunity for the commit author to describe the purpose of that commit with respect to the parents.


Branches are pointers
In Git, we move around the history and make changes without referring to OIDs most of the time. 
This is because branches provide pointers to the commits we care about. A branch with name main is actually a reference in Git called refs/heads/main. 
These files literally contain hex strings referencing the OID of a commit. As you work, these references change their contents to point to other commits.

This means branches are significantly different from our previous Git objects. 
Commits, trees, and blobs are immutable, meaning you can’t change their contents. 
If you change the contents, then you get a different hash and thus a new OID referring to the new object! Branches are named by users to provide meaning, such as trunk or my-special-project. We use branches to track and share work.

The special reference HEAD points to the current branch. When we add a commit to HEAD, it automatically updates that branch to the new commit.

Let’s put all of these new terms into one giant picture. 
Branches point to commits, commits point to other commits and their root trees, trees point to blobs and other trees, and blobs don’t point to anything

git log --reverse   --> displays the commit history in reverse order

https://www.freecodecamp.org/news/boost-programming-skills-read-git-code/


**** UNDO MISTAKES WITH GIT ****

1. Discarding local changes in a file (that also includes deleting a file)

To discard changes in particular files
git restore <filename> 
git checkout <filename> 

To discard all changes
git restore .
git checkout .

discarding uncommited local changes cannot be undone.

2. Discarding chunks / lines in a file

git restore -p or git restore -p <filename>        -p is for --patch mode

this command make git go into interactive mode as shown below

diff --git a/playlist.txt b/playlist.txt
index fb4ca6e..900049d 100644
--- a/playlist.txt
+++ b/playlist.txt
@@ -1,4 +1,5 @@
 Songs - Artist
+argaeveve
 ++++++++++++++
 ==============
 Swalla - Jason Derulo
(1/2) Discard this hunk from worktree [y,n,q,a,d,j,J,g,/,e,?]? 

prompts for a response from us

y - yes discard this hunk
n - no do not discard this hunk
q - quit; do not stage this hunk or any of the remaining ones

3. Fixing last commit

Editing last commit messasge

git commit --amend -m "crt/new commit msg"    ---> to change the last commit mesage

In case we need to add changes to the last commit

git add <changes to add to last commit>

git commit --amend -m <crt/new commit msg>

***  --amend rewrites history. Never change history of commits that already been pushed to a remote repository. ***

Everytime we amend the commmit hash changes, 
In the background a completly new commit object is created and swaps out the old one.

This is what RE WRITING history means. i.e, the new commits being exchanged in the background

4. Reverting a commit in the middle

git revert creates a new commit that reverts the effects of the specified commit.

git revert <COMMIT HASH>    ---> This prompts for a new commit message. Git also provides a clean default commit msg.

You can skip this revert commit with "git revert --skip"

To abort and get back to the state before "git revert",
hint: run "git revert --abort"

5. Resetting to an older version

git reset --hard <COMMIT HASH>

6. Recovering deleted commits

git reflog  -  a journal that log every COMMIT HASH, the HEAD has been to.

using git reflog get the COMMIT HASH from which we need, then we can create a new branch from that COMMIT, as

git branch <new-branch-name> <COMMIT HASH>   ---> Now this new branch will contain all the older commits from the specified COMMIT

7. Recovering a deleted branch

Similarly like recovering deleted commits, using git reflog get the COMMIT HASH, the HEAD was pointing to before deleting the branch, then

git branch <branch-name> <COMMIT HASH>

************* GIT ---- FAQ **************

Git does not track Empty directories














Removing untracked file using git

git clean -n  ---> runs a dry run and shows what its going to do
git clean -f  ---> force deletes the untracked files and changes
git clean -i  ---> opens an interactive session:



















